# Detecting confounding and instrumental elements
This repository contains the code through which research has been conducted regarding the detection of confounding elements, but also of instrumental variables in Bayesian networks. It can reproduce the results found in [this paper](https://arxiv.org/pdf/2205.13935.pdf). The program has also been used to detect whether is it possible to verify the presence of an instrumental variable in a simple graph with 4 nodes - one of which being a confounding element, but unfortunately, with little success. There was no d-separation found such that all of the criterias are met for an instrumental variable. Currently, there is research undergoing on whether a node can be checked as being an instrumental variable in a graph with 5 nodes - 2 of which are confounding elements.

# Input, Output format and Implementation
This repository contains multiple files with multiple functions, each with its own purpose. The main.py file is the one which is called and the one which makes use of the rest of the functions. Changes can be made to this file, depending on the desired output. For example, there are 3 input files from which information can be read: paper_input.txt - used to reproduce the results form the paper, instrumental_input.txt - used to check for the instrumental variable in the graph with 4 nodes and multiple_counfoundings.txt - used to check for the instrumental variable in the graph with 5 nodes, 2 of which are counfounding elements. This input file can be changed by changing the "fin" variable, which represents the input file.

The input files follow the same format: the number of nodes - n is present on the first line. On the next line, n characters can be found, each denoting a separate node. The last one/two node(s) represent the confounding elements. In order to enable the backtracking method, there are 3 types of edges defined: type 0, type 1 amd type 2. An edge is represented by 2 nodes, and if the edge is of type 0, the edge will remain as it is (so, for example, if the edge is described as "X Y", the edge will be from X to Y). A type 1 edge means that either the edge is as it is, or it is not present. A type 2 edge means that the edge is as it is, it is not present, or it is reversed (so, in the previous example with "X Y", the normal edge is X->Y, while the reversed edge is Y<-X). As a result, the next line contains the number of type 0 edges, followed by the type 0 edges on separate lines and the same for type 1 and type 2 edges. On the next 2 lines, the input files will contain the number of nodes that can be considered in the d-separation and the actual nodes that can be part of a d-separation. Thus, a node from that list can either be part of the d-separation or not. The next 2 lines will contain all the possible nodes that can be start or end nodes. Finally, the last line will contain the information needed in order to check whether a node is instrumental or not. Since the original paper does not check anything regarding instrumental variables, the instrumental info there is random as it will not be utilized.

The most important aspect regarding the code is the usage of backtracking, which enabled the program to search for every possible graph, d-separation and the start/end nodes. The implementation for this can be found in the backtracking.py file. Moreover, the functions needed to change the graph, d-separation or start/end nodes can also be found there. These functions are called recursively, and first, all of the possible graphs are computed and verified for any special properties. When all of the possible graphs have been tried, the program changes the d-separation, and then it verifies, once again all the possible graphs. Again, if no graphs are found, the d-separation will again be changed. This process continues, until all of the possible d-separations have been tested. Then, the program finally changes the start node and once again checks for all of the possible graphs and d-separations. It then changes the start node, and when all of the possible start nodes have been verified, it will then change the end node, resetting the start node to the initial node. It will then slowly change the end node, until it reaches the end - then the program finally stops.

In order to check whether 2 nodes are independent or not in a given graph, the solution from [the paper](https://arxiv.org/pdf/2205.13935.pdf) has been utilized. Therefore, it is essential to mirror the graph and create the theta nodes. Afterwards, a Breadth First Search algorithm has been implemented, in order to check for the independence of the start and end nodes. For this, the special properties of the nodes in a Bayesian network have of been taken into account (for example, an immorality which is not conditioned on, blocks the path). Depending on the desired outcome, the output file can vary. Nonetheless, it will always print the start and end nodes, and on separate lines, the current d-separation with the current graphs separated by "|||". After that, True or False can be printed for each combination possible, depending on the desired output. 
